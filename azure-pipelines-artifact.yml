---
# .azure-pipelines.yml
# Purpose: CI/CD for fullstack app artifacts (DOES NOT DEPLOY INFRASTRUCTURE)
# - Backend: Python Azure Functions (Flex Consumption)
# - Frontend: Angular → Azure Static Web Apps
# - Path-based conditions: only runs stages when relevant files change
# - Infrastructure deployment is handled by azure-pipelines-infra.yml
# Notes:
# - Deploys on branch 'main' temporaily (builds on PRs too)
# - Uses a stable Angular output path: 'dist/'
# - Requires infrastructure to be deployed first via azure-pipelines-infra.yml
# - Requires:
#     - Service connection: 'portfolio' (for SWA)
#     - Service connection: 'porfolio-repro' (for Function App)
#     - Variable group: 'portfolio-secrets' with SWA_TOKEN (fallback if needed)

variables:
  - name: AzureServiceConnection
    value: 'svc-portfolio-rg-conn'
  - name: Python_Version
    value: '3.11'
  - name: Node_Version
    value: '20.x'
  - group: portfolio-secrets

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - api/**
      - src/**
      - angular.json
      - package.json
      - package-lock.json
      - tsconfig.json
      - staticwebapp.config.json
    exclude:
      - infra/**
      - azure-pipelines-infra.yml
      - README.md
      - docs/**

pr:
  branches:
    include:
      - main
      - feature/*
  paths:
    include:
      - api/**
      - src/**
      - angular.json
      - package.json
      - package-lock.json
      - tsconfig.json
      - staticwebapp.config.json
      - infra/outputs.env
    exclude:
      - infra/**
      - azure-pipelines-infra.yml
      - README.md
      - docs/**

stages:

  # -----------------------------
  # Infrastructure Outputs
  # -----------------------------
  - stage: Load_Infrastructure_Outputs
    displayName: "Load Infrastructure Outputs"
    jobs:
      - job: load_infra_outputs
        displayName: "Load Infrastructure Outputs"
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: "1"
          - script: |
              set -e
              file="infra/outputs.env"
              if [ ! -f "$file" ]; then
                echo "Missing $file. Run infra-run.sh locally and commit it."
                exit 1
              fi
              . "$file"

              echo "🔍 Resolved Infrastructure Resources:"
              echo "  Resource Group: ${ResourceGroupName:-'Not set'}"
              echo "  Function App: ${FunctionAppName:-'Not set'}"
              echo "  Static Web App: ${StaticWebAppName:-'Not set'}"
              echo "  Storage Account: ${StorageAccountName:-'Not set'}"
              echo "  Key Vault: ${KeyVaultName:-'Not set'}"
              echo "  User Assigned Identity: ${UserAssignedIdentityName:-'Not set'}"

              # Set pipeline-level variables for all subsequent stages
              echo "##vso[task.setvariable variable=FunctionAppName;isOutput=true]$FunctionAppName"
              echo "##vso[task.setvariable variable=ResourceGroupName;isOutput=true]$ResourceGroupName"
              echo "##vso[task.setvariable variable=StorageAccountName;isOutput=true]$StorageAccountName"
              echo "##vso[task.setvariable variable=KeyVaultName;isOutput=true]$KeyVaultName"
              echo "##vso[task.setvariable variable=StaticWebAppName;isOutput=true]$StaticWebAppName"
              echo "##vso[task.setvariable variable=UserAssignedIdentityName;isOutput=true]$UserAssignedIdentityName"
              echo "Loaded infra outputs."
            name: loadOutputs
            displayName: "Load infra outputs"

  # -----------------------------
  # Backend: Build & Package
  # -----------------------------
  - stage: Backend_Build_Package
    displayName: "Backend (Functions) — Build & Package"
    dependsOn: Load_Infrastructure_Outputs
    jobs:
      - job: check_backend_changes
        displayName: "Check Backend Changes"
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: "0"
          - script: |
              git fetch origin --prune || true
              if [ "$BUILD_REASON" = "ResourceTrigger" ]; then
                echo "Triggered by infra pipeline; forcing backend deploy"
                echo "##vso[task.setvariable variable=BackendChanged;isOutput=true]true"
              else
                # Check if origin/main exists and if we can compare
                if git rev-parse --verify origin/main >/dev/null 2>&1; then
                  # Check for differences with origin/main
                  changed_files=$(git diff --name-only origin/main...HEAD || echo "")
                  if [ -z "$changed_files" ]; then
                    echo "No diff with origin/main found - treating as first-time deployment"
                    echo "##vso[task.setvariable variable=BackendChanged;isOutput=true]true"
                  elif echo "$changed_files" | grep -E "^api/"; then
                    echo "Backend changes detected: $(echo "$changed_files" | grep -E "^api/" | tr '\n' ' ')"
                    echo "##vso[task.setvariable variable=BackendChanged;isOutput=true]true"
                  else
                    echo "No backend changes detected"
                    echo "##vso[task.setvariable variable=BackendChanged;isOutput=true]false"
                  fi
                else
                  echo "origin/main not found - treating as first-time deployment"
                  echo "##vso[task.setvariable variable=BackendChanged;isOutput=true]true"
                fi
              fi
            name: checkChanges
            displayName: "Check for backend changes"

      - job: build_backend
        displayName: "Build Function App (zip)"
        dependsOn: check_backend_changes
        condition: >-
          eq(dependencies.check_backend_changes.outputs['checkChanges.BackendChanged'], 'true')
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '$(Python_Version)'

          # Install direct (for tests or tooling); build reproducibility comes from vendoring step
          - script: |
              python -m pip install --upgrade pip
              pip install -r requirements.txt
            displayName: "Install dependencies (tools)"
            workingDirectory: '$(Build.SourcesDirectory)/api'

          # Vendor dependencies into .python_packages per Azure Functions Python guidance
          - script: |
              pip install -r requirements.txt --target .python_packages/lib/site-packages
              rm -f local.settings.json || true
              find . -type d -name "__pycache__" -prune -exec rm -rf {} +
            displayName: "Vendor deps & clean"
            workingDirectory: '$(Build.SourcesDirectory)/api'

          # Create deployment zip
          - task: ArchiveFiles@2
            displayName: "Archive Function App to zip"
            inputs:
              rootFolderOrFile: '$(Build.SourcesDirectory)/api'
              includeRootFolder: false
              archiveType: zip
              archiveFile: '$(Build.ArtifactStagingDirectory)/api.zip'
              replaceExistingArchive: true

          - task: PublishBuildArtifacts@1
            displayName: "Publish API artifact"
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)/api.zip'
              ArtifactName: 'api'
              publishLocation: 'Container'

  # -----------------------------
  # Backend: Deploy
  # -----------------------------
  - stage: Backend_Deploy
    displayName: "Backend (Functions)"
    dependsOn: 
      - Load_Infrastructure_Outputs
      - Backend_Build_Package
    variables:
      FunctionAppName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.FunctionAppName']]
      ResourceGroupName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.ResourceGroupName']]
      StorageAccountName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.StorageAccountName']]
      KeyVaultName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.KeyVaultName']]
      StaticWebAppName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.StaticWebAppName']]
      UserAssignedIdentityName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.UserAssignedIdentityName']]
    condition: >-
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          eq(variables['Build.Reason'], 'ResourceTrigger')
        ),
        eq(dependencies.Backend_Build_Package.outputs['check_backend_changes.checkChanges.BackendChanged'], 'true')
      )
    jobs:
      - deployment: deploy_backend
        displayName: "Deploy Functions"
        environment: "portfolio-dev"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  fetchDepth: "1"

                - script: |
                    echo "FunctionAppName=$(FunctionAppName)"
                    echo "ResourceGroupName=$(ResourceGroupName)"
                    echo "Build.SourceBranch=$(Build.SourceBranch)"
                  displayName: "Debug resolved variables"

                - task: AzureCLI@2
                  displayName: "Verify Function App Exists"
                  inputs:
                    azureSubscription: '$(AzureServiceConnection)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      if az functionapp show --name $(FunctionAppName) \
                          --resource-group $(ResourceGroupName) \
                          --query name -o tsv; then
                        echo "Function App $(FunctionAppName) exists."
                      else
                        echo "Function App $(FunctionAppName) does not exist. Please create it first."
                        exit 1
                      fi

                - task: AzureFunctionApp@2
                  displayName: "Deploy Azure Function App (Flex)"
                  inputs:
                    azureSubscription: '$(AzureServiceConnection)'
                    appType: 'functionAppLinux'
                    isFlexConsumption: true
                    appName: '$(FunctionAppName)'
                    package: '$(Pipeline.Workspace)/api/api.zip'
                    resourceGroupName: '$(ResourceGroupName)'

  # -----------------------------
  # Frontend: Build & Deploy SWA
  # -----------------------------
  - stage: Frontend_Deploy_SWA
    displayName: "Frontend (Angular) — Deploy to Azure Static Web Apps"
    dependsOn: Load_Infrastructure_Outputs
    variables:
      FunctionAppName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.FunctionAppName']]
      ResourceGroupName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.ResourceGroupName']]
      StorageAccountName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.StorageAccountName']]
      KeyVaultName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.KeyVaultName']]
      StaticWebAppName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.StaticWebAppName']]
      UserAssignedIdentityName: $[stageDependencies.Load_Infrastructure_Outputs.load_infra_outputs.outputs['loadOutputs.UserAssignedIdentityName']]
    condition: >-
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          eq(variables['Build.Reason'], 'ResourceTrigger')
        )
      )
    jobs:
      - job: check_frontend_changes
        displayName: "Check Frontend Changes"
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: "0"
          - script: |
              git fetch origin --prune || true
              if [ "$BUILD_REASON" = "ResourceTrigger" ]; then
                echo "Triggered by infra pipeline; forcing frontend deploy"
                echo "##vso[task.setvariable variable=FrontendChanged;isOutput=true]true"
              else
                # Check if origin/main exists and if we can compare
                if git rev-parse --verify origin/main >/dev/null 2>&1; then
                  # Check for differences with origin/main
                  changed_files=$(git diff --name-only origin/main...HEAD || echo "")
                  if [ -z "$changed_files" ]; then
                    echo "No diff with origin/main found - treating as first-time deployment"
                    echo "##vso[task.setvariable variable=FrontendChanged;isOutput=true]true"
                  elif echo "$changed_files" | grep -E "^(src/|angular\.json|package\.json|package-lock\.json|tsconfig\.json|staticwebapp\.config\.json)"; then
                    echo "Frontend changes detected: $(echo "$changed_files" | grep -E "^(src/|angular\.json|package\.json|package-lock\.json|tsconfig\.json|staticwebapp\.config\.json)" | tr '\n' ' ')"
                    echo "##vso[task.setvariable variable=FrontendChanged;isOutput=true]true"
                  else
                    echo "No frontend changes detected"
                    echo "##vso[task.setvariable variable=FrontendChanged;isOutput=true]false"
                  fi
                else
                  echo "origin/main not found - treating as first-time deployment"
                  echo "##vso[task.setvariable variable=FrontendChanged;isOutput=true]true"
                fi
              fi
            name: checkChanges
            displayName: "Check for frontend changes"

      - deployment: deploy_frontend
        displayName: "Build & Deploy SWA"
        dependsOn: check_frontend_changes
        condition: >-
          eq(dependencies.check_frontend_changes.outputs['checkChanges.FrontendChanged'], 'true')
        environment: "portfolio-dev"
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self    # ensure source is available for npm
                  fetchDepth: "1"

                - task: NodeTool@0
                  inputs:
                    versionSpec: '$(Node_Version)'

                # Optional but recommended: clean install
                - script: |
                    npm ci
                    npm run build:prod
                  displayName: "Build Angular (production)"
                  workingDirectory: '$(Build.SourcesDirectory)'

                - script: |
                    if [ -f staticwebapp.config.json ]; then
                      mkdir -p dist/browser
                      cp staticwebapp.config.json dist/browser/staticwebapp.config.json
                    fi
                  displayName: "Include SWA config in dist"
                  workingDirectory: '$(Build.SourcesDirectory)'

                - task: AzureStaticWebApp@0
                  displayName: "Deploy to Azure Static Web Apps"
                  inputs:
                    azure_static_web_apps_api_token: '$(SWA_TOKEN)'
                    workingDirectory: '$(Build.SourcesDirectory)'
                    action: 'upload'
                    app_location: 'dist/browser'
                    api_location: ''
                    output_location: ''
                    skip_app_build: true
                    skip_api_build: true
